{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AxenLang Language Specification","text":"<p>This document specifies the syntax and semantics of the AxenLang programming language.</p> <p>Compiler Implementation: github.com/arsoniv/axenc</p>"},{"location":"#overview","title":"Overview","text":"<p>AxenLang is a statically-typed, compiled programming language that targets LLVM IR. The language provides primitive types, user-defined types, functions, classes, pointers, and arrays.</p>"},{"location":"#specification-sections","title":"Specification Sections","text":"<ul> <li>Lexical Structure - Tokens, keywords, literals, and identifiers</li> <li>Types - Primitive types, pointers, arrays, and classes</li> <li>Expressions - Operations, precedence, and evaluation</li> <li>Statements - Control flow and variable declarations</li> <li>Declarations - Functions, classes, and type definitions</li> <li>Program Structure - Imports and compilation units</li> </ul>"},{"location":"declarations/","title":"Declarations","text":""},{"location":"declarations/#function-declarations","title":"Function Declarations","text":"<p>A function declaration specifies a return type, name, parameter list, and body.</p> <pre><code>returnType functionName(paramType1 param1, paramType2 param2) {\n  // function body\n}\n</code></pre>"},{"location":"declarations/#parameters","title":"Parameters","text":"<p>Parameters are declared with type and name. Multiple parameters are separated by commas.</p> <pre><code>int add(int a, int b) {\n  return a + b;\n}\n\nvoid process(int x, ptr float data) {\n  // implementation\n}\n</code></pre>"},{"location":"declarations/#return-type","title":"Return Type","text":"<p>Functions must declare a return type. Functions returning no value use <code>void</code>.</p> <pre><code>void noReturn() {\n  // no return statement needed\n}\n\nint getValue() {\n  return 42;\n}\n</code></pre>"},{"location":"declarations/#class-declarations","title":"Class Declarations","text":"<p>A class declaration defines an aggregate type with members and methods.</p> <pre><code>class ClassName {\n  memberType1 member1;\n  memberType2 member2;\n}\n</code></pre>"},{"location":"declarations/#members","title":"Members","text":"<p>Class members are typed fields (without any initalised values)</p> <pre><code>class Rectangle {\n  int width;\n  int height;\n}\n</code></pre>"},{"location":"declarations/#methods","title":"Methods","text":"<p>Methods are functions associated with a class. They are declared outside the class body with the naming convention <code>ClassName_methodName</code>.</p> <pre><code>class Counter {\n  int value;\n}\n\nvoid Counter_init(ptr Counter this) {\n  this.value = 0;\n}\n\nvoid Counter_increment(ptr Counter this) {\n  this.value = this.value + 1;\n}\n\nint Counter_getValue(ptr Counter this) {\n  return this.value;\n}\n</code></pre> <p>Methods receive a pointer to the instance as the first parameter, conventionally named <code>this</code>.</p>"},{"location":"declarations/#method-calls","title":"Method Calls","text":"<p>Methods are invoked using member access syntax on instances.</p> <pre><code>Counter c;\nc.init();\nc.increment();\nint val;\nval = c.getValue();\n</code></pre> <p>The compiler automatically passes the instance address as the first argument.</p>"},{"location":"declarations/#type-definitions","title":"Type Definitions","text":""},{"location":"declarations/#typedef","title":"typedef","text":"<p>The <code>typedef</code> keyword creates a type alias.</p> <pre><code>typedef AliasName ExistingType;\n</code></pre> <p>Examples:</p> <pre><code>typedef Size int;\ntypedef CharPtr ptr char;\n</code></pre>"},{"location":"declarations/#intdef","title":"intdef","text":"<p>The <code>intdef</code> keyword defines named integer constants.</p> <pre><code>intdef ConstantName value;\n</code></pre> <p>Examples:</p> <pre><code>intdef MAX_COUNT 100;\nintdef BUFFER_SIZE 1024;\n</code></pre> <p>Named constants defined with <code>intdef</code> can be used in expressions wherever integer literals are valid.</p>"},{"location":"declarations/#global-scope","title":"Global Scope","text":"<p>Functions and classes are declared at global scope. Variables cannot be declared at global scope; they must be declared within functions.</p>"},{"location":"expressions/","title":"Expressions","text":""},{"location":"expressions/#primary-expressions","title":"Primary Expressions","text":""},{"location":"expressions/#literals","title":"Literals","text":"<p>Integer, floating-point, and string literals are primary expressions.</p> <pre><code>42\n3.14\n\"hello\"\n</code></pre>"},{"location":"expressions/#identifiers","title":"Identifiers","text":"<p>An identifier referring to a variable or constant is a primary expression.</p> <pre><code>x\ncount\n</code></pre>"},{"location":"expressions/#parenthesized-expressions","title":"Parenthesized Expressions","text":"<p>An expression enclosed in parentheses is a primary expression.</p> <pre><code>(x + y)\n</code></pre>"},{"location":"expressions/#function-calls","title":"Function Calls","text":"<p>A function call consists of a function name followed by a parenthesized argument list.</p> <pre><code>functionName(arg1, arg2)\n</code></pre>"},{"location":"expressions/#postfix-expressions","title":"Postfix Expressions","text":""},{"location":"expressions/#array-subscripting","title":"Array Subscripting","text":"<p>An expression followed by a bracketed index accesses an array element.</p> <pre><code>array[0]\nmatrix[i][j]\n</code></pre>"},{"location":"expressions/#member-access","title":"Member Access","text":"<p>The <code>.</code> operator accesses a member of a class.</p> <pre><code>point.x\nobject.field\n</code></pre> <p>Member access on pointer types automatically dereferences the pointer.</p> <pre><code>ptr.member     // equivalent to ($ptr).member\n</code></pre>"},{"location":"expressions/#method-calls","title":"Method Calls","text":"<p>Methods are called using member access syntax.</p> <pre><code>object.method(args)\n</code></pre> <p>Methods receive an implicit pointer to the object as the first parameter.</p>"},{"location":"expressions/#prefix-expressions","title":"Prefix Expressions","text":""},{"location":"expressions/#address-of-operator","title":"Address-Of Operator","text":"<p>The <code>&amp;</code> operator produces the address of its operand.</p> <pre><code>&amp;variable\n</code></pre> <p>The operand must be an lvalue.</p>"},{"location":"expressions/#dereference-operator","title":"Dereference Operator","text":"<p>The <code>$</code> operator dereferences a pointer.</p> <pre><code>$pointer\n</code></pre> <p>Multiple dereferences may be chained.</p> <pre><code>$$doublePointer\n</code></pre>"},{"location":"expressions/#unary-minus","title":"Unary Minus","text":"<p>The <code>-</code> operator negates its operand.</p> <pre><code>-x\n-42\n</code></pre>"},{"location":"expressions/#binary-expressions","title":"Binary Expressions","text":""},{"location":"expressions/#arithmetic-operators","title":"Arithmetic Operators","text":"<pre><code>x + y    addition\nx - y    subtraction\nx * y    multiplication\nx / y    division\nx % y    modulo\n</code></pre>"},{"location":"expressions/#comparison-operators","title":"Comparison Operators","text":"<pre><code>x == y   equality\nx &lt; y    less than\nx &gt; y    greater than\n</code></pre>"},{"location":"expressions/#logical-operators","title":"Logical Operators","text":"<pre><code>x &amp; y    bitwise AND\n</code></pre>"},{"location":"expressions/#operator-precedence","title":"Operator Precedence","text":"<p>Operators are evaluated according to the following precedence (highest to lowest):</p> <ol> <li>Primary expressions (literals, identifiers, calls, subscripts, member access)</li> <li>Prefix operators (<code>&amp;</code>, <code>$</code>, <code>-</code>)</li> <li>Multiplication, division, modulo (<code>*</code>, <code>/</code>, <code>%</code>)</li> <li>Addition, subtraction (<code>+</code>, <code>-</code>)</li> <li>Comparison (<code>&lt;</code>, <code>&gt;</code>)</li> <li>Equality (<code>==</code>)</li> <li>Bitwise AND (<code>&amp;</code>)</li> </ol> <p>Operators of the same precedence associate left-to-right.</p>"},{"location":"expressions/#type-requirements","title":"Type Requirements","text":"<p>Binary arithmetic and comparison operators require operands of the same signedness. Mixing signed and unsigned operands produces a semantic error.</p>"},{"location":"expressions/#evaluation","title":"Evaluation","text":"<p>Expressions are evaluated left-to-right respecting precedence and associativity rules. There are no short-circuit evaluation semantics for logical operators.</p>"},{"location":"lexical/","title":"Lexical Structure","text":""},{"location":"lexical/#character-set","title":"Character Set","text":"<p>Source files are processed as sequences of Unicode characters encoded in UTF-8.</p>"},{"location":"lexical/#comments","title":"Comments","text":"<p>Single-line comments begin with <code>//</code> and continue to the end of the line.</p> <pre><code>// This is a comment\n</code></pre> <p>Single-line comments begin with <code>/*</code> and continue to the next <code>*/</code>.</p> <pre><code>/* This is a comment */\n</code></pre>"},{"location":"lexical/#identifiers","title":"Identifiers","text":"<p>Identifiers consist of letters and digits. The first character must be a letter.</p> <p>Restriction: Underscores (<code>_</code>) are not permitted in identifiers.</p> <pre><code>validName\nName123\n</code></pre>"},{"location":"lexical/#keywords","title":"Keywords","text":"<p>The following identifiers are reserved as keywords:</p> <pre><code>return    break     continue  if        while     else\nptr       import    class     typedef   intdef\n</code></pre>"},{"location":"lexical/#literals","title":"Literals","text":""},{"location":"lexical/#integer-literals","title":"Integer Literals","text":"<p>Integer literals may be specified in decimal or hexadecimal notation.</p> <ul> <li>Decimal: sequence of digits</li> <li>Hexadecimal: <code>0x</code> or <code>0X</code> followed by hexadecimal digits</li> </ul> <pre><code>42\n0xFF\n0x1A2B\n</code></pre>"},{"location":"lexical/#floating-point-literals","title":"Floating-Point Literals","text":"<p>Floating-point literals consist of digits with a decimal point.</p> <pre><code>3.14\n0.5\n</code></pre>"},{"location":"lexical/#string-literals","title":"String Literals","text":"<p>String literals are sequences of characters enclosed in double quotes.</p> <pre><code>\"hello\"\n\"example string\"\n</code></pre>"},{"location":"lexical/#operators-and-punctuation","title":"Operators and Punctuation","text":""},{"location":"lexical/#arithmetic-operators","title":"Arithmetic Operators","text":"<pre><code>+    addition\n-    subtraction\n*    multiplication\n/    division\n%    modulo\n</code></pre>"},{"location":"lexical/#comparison-operators","title":"Comparison Operators","text":"<pre><code>==   equal to\n&lt;    less than\n&gt;    greater than\n</code></pre>"},{"location":"lexical/#logical-operators","title":"Logical Operators","text":"<pre><code>&amp;    bitwise AND (also used for address-of)\n</code></pre>"},{"location":"lexical/#pointer-operators","title":"Pointer Operators","text":"<pre><code>&amp;    address-of\n$    dereference\n</code></pre>"},{"location":"lexical/#delimiters","title":"Delimiters","text":"<pre><code>(    )    left and right parentheses\n{    }    left and right braces\n[    ]    left and right brackets\n</code></pre>"},{"location":"lexical/#other-symbols","title":"Other Symbols","text":"<pre><code>.    member access\n,    comma separator\n;    statement terminator\n=    assignment\n</code></pre>"},{"location":"program/","title":"Program Structure","text":""},{"location":"program/#compilation-units","title":"Compilation Units","text":"<p>A source file is a compilation unit containing declarations. The file extension is <code>.ax</code>.</p>"},{"location":"program/#import-statement","title":"Import Statement","text":"<p>The <code>import</code> statement includes declarations from another source file.</p> <pre><code>import \"filename.ax\";\n</code></pre> <p>The filename is specified as a string literal and is resolved relative to the importing file.</p>"},{"location":"program/#import-semantics","title":"Import Semantics","text":"<ul> <li>Imports are processed at compile time</li> <li>All declarations from the imported file become available in the importing file</li> <li>Circular imports should be avoided</li> <li>Each file is processed once; multiple imports of the same file do not cause duplication</li> </ul>"},{"location":"program/#entry-points","title":"Entry Points","text":"<p>AxenLang does not require a specific entry point function. Any function may serve as the entry point depending on the linking configuration.</p> <p>When linking with the C runtime, a function named <code>main</code> with the C-compatible signature is used:</p> <pre><code>int main() {\n  return 0;\n}\n</code></pre> <p>For standalone executables or custom runtimes, any function can be designated as the entry point.</p>"},{"location":"program/#compilation-model","title":"Compilation Model","text":"<ol> <li>The compiler parses the root source file</li> <li>Import statements are resolved and imported files are parsed</li> <li>All declarations are collected across all compilation units</li> <li>Type checking and semantic analysis are performed</li> <li>LLVM IR is generated for all functions</li> <li>The output is an object file or LLVM IR text</li> </ol>"},{"location":"program/#linking","title":"Linking","text":"<p>Generated object files can be linked with: - C standard library - Custom runtime libraries - Other object files from C, C++, or AxenLang</p> <p>The linking process determines the actual entry point and resolves external symbols.</p>"},{"location":"statements/","title":"Statements","text":""},{"location":"statements/#variable-declaration","title":"Variable Declaration","text":"<p>A variable declaration specifies a type and identifier.</p> <pre><code>int x;\nfloat value;\nPoint p;\n</code></pre> <p>Variables are stack-allocated and uninitialized at declaration.</p>"},{"location":"statements/#assignment-statement","title":"Assignment Statement","text":"<p>Assignment updates the value of a variable or lvalue.</p> <pre><code>x = 10;\narray[i] = value;\nobject.field = 42;\n</code></pre> <p>The left operand must be an lvalue. The right operand is an expression.</p> <p>Assignment is a statement, not an expression. <code>if (x = 5)</code> is not valid syntax.</p>"},{"location":"statements/#expression-statement","title":"Expression Statement","text":"<p>An expression followed by a semicolon forms a statement.</p> <pre><code>functionCall();\nobject.method();\n</code></pre>"},{"location":"statements/#return-statement","title":"Return Statement","text":"<p>The <code>return</code> statement exits a function, optionally returning a value.</p> <pre><code>return;           // void return\nreturn 42;        // return with value\nreturn x + y;     // return expression result\n</code></pre> <p>A function with non-void return type must return a value. A function with void return type must not return a value.</p>"},{"location":"statements/#if-statement","title":"If Statement","text":"<p>The <code>if</code> statement conditionally executes a block of statements.</p> <pre><code>if (condition) {\n  // statements\n}\n</code></pre> <p>An optional <code>else</code> clause executes when the condition is false.</p> <pre><code>if (condition) {\n  // true branch\n} else {\n  // false branch\n}\n</code></pre>"},{"location":"statements/#while-statement","title":"While Statement","text":"<p>The <code>while</code> statement repeatedly executes a block while a condition is true.</p> <pre><code>while (condition) {\n  // loop body\n}\n</code></pre>"},{"location":"statements/#break-statement","title":"Break Statement","text":"<p>The <code>break</code> statement exits the innermost loop.</p> <pre><code>break;\n</code></pre>"},{"location":"statements/#continue-statement","title":"Continue Statement","text":"<p>The <code>continue</code> statement skips to the next iteration of the innermost loop.</p> <pre><code>continue;\n</code></pre>"},{"location":"statements/#compound-statement","title":"Compound Statement","text":"<p>A compound statement is a sequence of statements enclosed in braces.</p> <pre><code>{\n  int x;\n  x = 10;\n  functionCall(x);\n}\n</code></pre> <p>Compound statements introduce a new scope for variable declarations.</p>"},{"location":"statements/#scope-rules","title":"Scope Rules","text":"<p>Variables are scoped to the block in which they are declared. Inner blocks may shadow outer variables with the same name. Variables are visible from their declaration point to the end of the enclosing block.</p>"},{"location":"types/","title":"Types","text":""},{"location":"types/#primitive-types","title":"Primitive Types","text":""},{"location":"types/#void-type","title":"Void Type","text":"<pre><code>void\n</code></pre> <p>Represents absence of a value. Used as function return type for functions that do not return a value.</p>"},{"location":"types/#boolean-type","title":"Boolean Type","text":"<pre><code>bool\n</code></pre> <p>Represents boolean values.</p>"},{"location":"types/#integer-types","title":"Integer Types","text":"<p>Integer types may be signed or unsigned. Signed types are prefixed without <code>u</code>, unsigned types with <code>u</code>.</p> <pre><code>char     uchar    8-bit\nshort    ushort   16-bit\nint      uint     32-bit\nlong     ulong    64-bit\n</code></pre>"},{"location":"types/#floating-point-types","title":"Floating-Point Types","text":"<p>Floating-point types are always signed.</p> <pre><code>half     16-bit\nfloat    32-bit\ndouble   64-bit\nquad     128-bit\n</code></pre>"},{"location":"types/#derived-types","title":"Derived Types","text":""},{"location":"types/#pointer-types","title":"Pointer Types","text":"<p>A pointer type is formed by applying <code>ptr</code> to a base type.</p> <pre><code>ptr int        // pointer to int\nptr ptr char   // pointer to pointer to char\n</code></pre>"},{"location":"types/#array-types","title":"Array Types","text":"<p>An array type specifies a fixed-size sequence of elements of a given type.</p> <pre><code>int[10]       // array of 10 integers\nfloat[5]      // array of 5 floats\n</code></pre> <p>Arrays can be multi-dimensional:</p> <pre><code>int[3][4]     // 3x4 array of integers\n</code></pre>"},{"location":"types/#class-types","title":"Class Types","text":"<p>Classes define aggregate types with named members.</p> <pre><code>class Point {\n  int x;\n  int y;\n}\n</code></pre> <p>Classes are value types and are passed by value unless explicitly converted to pointers.</p>"},{"location":"types/#type-aliases","title":"Type Aliases","text":"<p>Type aliases create alternative names for existing types.</p>"},{"location":"types/#typedef","title":"typedef","text":"<p>Creates an alias for a type.</p> <pre><code>typedef MyInt int;\ntypedef PointPtr ptr Point;\n</code></pre>"},{"location":"types/#intdef","title":"intdef","text":"<p>Defines named integer constants.</p> <pre><code>intdef MAX_SIZE 100;\n</code></pre>"},{"location":"types/#type-compatibility","title":"Type Compatibility","text":"<p>Types are compatible if they are identical. Integer operations require operands of the same signedness. Type conversions occur implicitly when:</p> <ul> <li>Converting between integer types of different widths (sign/zero extension or truncation)</li> <li>Integer to floating-point conversion</li> </ul> <p>Pointer types are only compatible with other pointer types pointing to the same base type.</p>"}]}